//
//  FCPXMLRole.swift
//  DAWFileKit • https://github.com/orchetect/DAWFileKit
//  © 2022 Steffan Andrews • Licensed under MIT License
//

#if os(macOS) // XMLNode only works on macOS

import Foundation
import OTCore

public protocol FCPXMLRole where Self: RawRepresentable, RawValue == String {
    /// Returns the role type enum case.
    var roleType: FinalCutPro.FCPXML.RoleType { get }
    
    /// Returns the annotation as ``FinalCutPro/FCPXML/AnyRole``.
    func asAnyRole() -> FinalCutPro.FCPXML.AnyRole
    
    /// Returns the role with its string lowercased.
    func lowercased(derivedOnly: Bool) -> Self
    
    /// Returns the role with its string title-cased.
    func titleCased(derivedOnly: Bool) -> Self
    
    /// Returns `true` if the role is a built-in role in Final Cut Pro (and not a user-defined
    /// role).
    var isMainRoleBuiltIn: Bool { get }
}

// MARK: - Equatable

extension FCPXMLRole {
    func isEqual(to other: some FCPXMLRole) -> Bool {
        self.asAnyRole() == other.asAnyRole()
    }
}

// MARK: - Collection Methods

extension Collection<FinalCutPro.FCPXML.AnyRole> {
    public func contains(_ element: any FCPXMLRole) -> Bool {
        contains(where: { $0.wrapped.isEqual(to: element) })
    }
}

extension Dictionary where Value == FinalCutPro.FCPXML.AnyRole {
    public func contains(value element: any FCPXMLRole) -> Bool {
        values.contains(element)
    }
}

extension Collection where Element: FCPXMLRole {
    public func contains(_ element: FinalCutPro.FCPXML.AnyRole) -> Bool {
        contains(where: { $0.asAnyRole() == element })
    }
}

extension Dictionary where Value: FCPXMLRole {
    public func contains(value element: FinalCutPro.FCPXML.AnyRole) -> Bool {
        values.contains(where: { $0.asAnyRole() == element })
    }
}

// MARK: - Nested Type Erasure

extension Collection where Element: FCPXMLRole {
    public func asAnyRoles() -> [FinalCutPro.FCPXML.AnyRole] {
        map { $0.asAnyRole() }
    }
}

extension Collection<FinalCutPro.FCPXML.AnyRole> {
    public func asAnyRoles() -> [FinalCutPro.FCPXML.AnyRole] {
        map { $0.asAnyRole() }
    }
}

// MARK: - Utilities

extension FinalCutPro.FCPXML {
    /// Utility:
    /// Parses raw audio or video role string and returns role and optional sub-role.
    static func parseRawStandardRole(
        rawValue: String
    ) throws -> (role: String, subRole: String?) {
        let roleWithOptionalSubRolePattern = #"^([^?.\n\t]+)(\.([^?.\n\t]+)){0,1}$"#
        let roleAndSubrole = rawValue.regexMatches(
            captureGroupsFromPattern: roleWithOptionalSubRolePattern,
            options: [.useUnicodeWordBoundaries]
        )
        
        guard roleAndSubrole.count == 4, // we burn a capture group for the period (.)
              let mainRole = roleAndSubrole[1]
        else {
            throw FinalCutPro.FCPXML.ParseError.general(
                "Malformed role encountered: \(rawValue.quoted)."
            )
        }
        
        // re-cast Substrings as Strings
        let mainRoleString = String(mainRole)
        let subRoleString = roleAndSubrole[3] != nil ? String(roleAndSubrole[3]!) : nil
        
        return (role: mainRoleString, subRole: subRoleString)
    }
    
    /// Utility:
    /// Parses raw caption role string and returns role and format/language code.
    static func parseRawCaptionRole(
        rawValue: String
    ) throws -> (role: String, captionFormat: String) {
        let captionRolePattern = #"^([^?.\n\t]+)\?captionFormat=([^?\n\t]+)$"#
        let roleAndSubrole = rawValue.regexMatches(
            captureGroupsFromPattern: captionRolePattern
        )
        
        guard roleAndSubrole.count == 3,
              let mainRole = roleAndSubrole[1],
              let format = roleAndSubrole[2]
        else {
            throw FinalCutPro.FCPXML.ParseError.general(
                "Malformed caption role encountered: \(rawValue.quoted)."
            )
        }
        
        // re-cast Substrings as Strings
        let mainRoleString = String(mainRole)
        let formatString = String(format)
        
        return (role: mainRoleString, captionFormat: formatString)
    }
    
    /// Utility:
    /// Strip off subrole if subrole is redundantly generated by FCP.
    /// ie: A role of `Role.Role-1` would return `Role`.
    static func collapseStandardSubRole(
        role inputRole: String,
        subRole inputSubRole: String?
    ) -> (role: String, subRole: String?) {
        let input = (role: inputRole, subRole: inputSubRole)
        
        guard let inputSubRole = inputSubRole else {
            return input
        }
        
        // interpret an empty sub-role string or whitespace-only sub-role as being nil
        guard !inputSubRole.trimmed.isEmpty else {
            return (role: inputRole, subRole: nil)
        }
        
        guard isSubRole(inputSubRole, derivedFromMainRole: input.role) else {
            return input
        }
        
        return (role: input.role, subRole: nil)
    }
    
    /// Utility:
    /// Returns `true` if the given sub-role is derived from the main role.
    ///
    /// - `Dialogue.Dialogue` or `Dialogue.Dialogue-1` are considered derivative.
    /// - `Dialogue.CustomRole` is not considered derivative.
    static func isSubRole(_ subRole: String?, derivedFromMainRole mainRole: String) -> Bool {
        guard let subRole = subRole,
              subRole.starts(with: mainRole)
        else { return false }
        
        if mainRole == subRole { return true }
        
        // just ensure the suffix matches the expected pattern, we don't care about its actual contents
        // since we already confirmed main role starts with the sub-role
        let subRoleSuffix = subRole.dropFirst(mainRole.count) // "-1", "-2", etc.
        let pattern = #"^\-([\d]+)$"#
        let suffixMatches = subRoleSuffix.regexMatches(pattern: pattern)
        
        return suffixMatches.count == 1
    }
}

#endif
